## javascript原型与闭包  

### 一切皆为对象  
对象的判断： 值类型（undefined，number，string，boolean）判断用 typeof；引用类型（函数，数组，对象，null）判断用instanceof。  
>对象： 若干（键值对）属性的集合  

### 函数与对象的关系  
函数是一种对象，通过instanceof判断。  
对象都是通过函数创建的。  

### prototype原型  
每一个函数都有prototype属性，这个prototype属性值是一个对象，默认只有一个constructor属性，指向该函数本身。
![prototype](./img/prototype.png)  
  >function Fn() { }  
  >var fn = new Fn();  

每个对象都有一个隐藏的属性（隐式原型）"\_\_proto\_\_",这个属性引用了创建这个对象的函数的prototype,即：  
fn.\_\_proto\_\_ === Fn.prototype。  
同，每个对象都有一个\_\_proto\_\_属性，指向创建该对象的函数的prototype。  
但是Object.prototype确实一个特例——它的__proto__指向的是null。  
函数是被Function创建的。  

### instanceof  
![prototype](./img/prototype_chain.png)  

Instanceof运算符的第一个变量是一个对象，暂时称为A；第二个变量一般是一个函数，暂时称为B。  

Instanceof的判断队则是：沿着A的__proto__这条线来找，同时沿着B的prototype这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回true。如果找到终点还未重合，则返回false。  

### 继承  
访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着__proto__这条链向上找，这就是原型链。  
由于所有的对象的原型链都会找到Object.prototype，因此所有的对象都会有Object.prototype的方法。这就是所谓的“继承”。  

### 原型的灵活性  
通过prototype属性对对象进行扩展。  

### 执行上下文  
函数声明：  
  function foo(){}  
函数表达式：  
  var foo = function(){}  
准备工作:  
- 变量、函数表达式——变量声明，默认赋值为undefined；
- this——赋值；
- 函数声明——赋值；  

这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。  
其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。  
函数每被调用一次，都会产生一个新的执行上下文环境。  
函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。  
在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。  

### this  
在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。  
因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。  
构造函数（new）：  
  this就代表它即将new出来的对象。  
  其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值。
函数作为对象的一个属性 ：  
  如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。  
函数用call或者apply调用 ：   
  当一个函数被call和apply调用时，this的值就取传入的对象的值。  
全局 & 调用普通函数：  
  在全局环境下，this永远是window。  
  普通函数在调用时，其中的this也都是window。  

### 执行上下文栈  
执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。`处于活动状态的执行上下文环境只有一个`。  

其实这是一个`压栈出栈的过程`——`执行上下文栈`。  
![执行上下文栈](./img/context_stack.png)  

### 作用域和上下文环境  
除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。  
如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。  

### 自由变量和作用域链  
自由变量为在`创建`这个函数的那个作用域中取的值，是“创建”，而不是“调用”，又称静态作用域。  
取自由变量时的这个“作用域链”过程：（假设a是自由量）  
1. 现在当前作用域查找a，如果有则获取并结束。如果没有则继续；  
1. 如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；  
1. （不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；  
1. 跳转到第一步。  

### 闭包  
闭包应用的两种情况：函数作为返回值，函数作为参数传递。
闭包的核心内容：  
函数调用完成之后，其执行上下文环境不会接着被销毁。  

使用闭包会增加内容开销
 



