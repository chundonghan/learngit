### JAVA基础
#### Arraylist与LinkedList
Arraylist:  
数组 查询 O(1) 插入删除 O(i)  
LinkedList:  
链表 查询 O(i) 插入删除 O(1)  
两者均为不同步的，即线程不安全  

#### 类实例化顺序：
先由父到子静态->父类代码块到构造函数->子类代码块到构造函数->类方法  

#### Java线程池
组成：一个线程集合workerSet和一个阻塞队列workQueue  
固定线程数量的线程池： newFixedThreadPool()  
只有一个线程的线程池： newSingleThreadExecutor()  
可具实际情况调整线程数量的线程池: newCachedThreadPool()  
计划定时任务线程池： newScheduledThreadPool()  

#### HashMap
HashMap是一个散列桶(bucket)，存储键值对。  
HashMap是基于hashing的原理。数据结构由数组和链表（红黑树）组成。  
\*两个键的hashcode相同:  
HashMap会使用键对象的hashcode找到bucket位置，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。  
 - 处理哈希冲突方法：  
开放地址法（再散列法）  
拉链法  
再哈希法  

#### ConcurrentHashMap
锁分段技术  
将数据分成一段一段的存储，给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。  
有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁。  
段数组是final的。  
ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。  



#### BIO、NIO、AIO
同步：用户进程触发I/O操作并等待或轮询地去查看I/O操作是否就绪  
异步：用户进程触发I/O操作以后便开始做自己的事情，而当I/O操作完成的时候会得到“I/O完毕”的通知  
阻塞：当试图对该文件描述符进行读写时，如果当时没有东西可读，或暂时不可写，程序就进入等待状态，直到有东西可读或可写为止  
非阻塞：如果没有东西可读，或不可写，读写函数马上返回，而不会等待  
I/O操作：  
发起I/O请求和实际的I/O操作  
同步和异步是针对应用程序和内核的交互而言的  
阻塞和非阻塞是针对于进程在访问数据时，根据I/O操作的就绪状态来采取的不同方式  
- BIO 同步阻塞  
    
- NIO 同步非阻塞  
    用户进程发起一个I/O操作以后便可返回做其他事情，但是用户进程需要时不时地询问I/O操作是否就绪，这就要求用户周期性地去询问  
- AIO 异步非阻塞  
    用户进程发起一个I/O操作以后，不等待内核I/O操作的完成，内核完成I/O操作以后会通知用户进程。  

### 线程  
#### 并发编程三要素
原子性、可见性、有序性
#### 多线程的价值
发挥多核CPU的优势、防止阻塞、便于建模
#### 创建线程的有哪些方式
继承Thread类创建线程类、通过Runnable接口创建线程类、通过Callable和Future创建线程
#### 创建线程的三种方式的对比
1. 采用实现Runnable、Callable接口的方式创建多线程  
    可以继承其他类,可以共享同一个target对象,非常适合多个相同线程来处理同一份资源的情况  
2. 使用继承Thread类的方式创建多线程  
    编写简单,不能再继承其他父类  
3. Runnable和Callable的区别  
    - Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()  
    - Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。  
    - Call方法可以抛出异常，run方法不可以  
    - 运行Callable任务可以拿到一个Future对象,通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。  

#### 线程池的优点
- 重用存在的线程，减少对象创建销毁的开销。  
- 可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。  
- 提供定时执行、定期执行、单线程、并发数控制等功能。  

#### synchronized的作用
控制线程同步、控制synchronized代码段不被多个线程同时执行  
既可以加在一段代码上，也可以加在方法上  
#### volatile关键字的作用  
保证可见性，保证修改的值会立即被更新到主存  
和CAS结合，保证了原子性  
CAS是compare and swap  
#### 多线程同步有哪几种方法
Synchronized关键字，Lock锁实现，分布式锁  
#### 同步方法和同步块，哪个是更好的选择
同步的范围越小越好
#### Java线程数过多会造成什么异常
线程的生命周期开销非常高、消耗过多的CPU资源、降低稳定性、
### 优化
#### Tomcat优化
- 禁用AJP连接  
    用不着AJP协议  
- 执行器Executor  
    每一个用户请求都是一个线程，使用线程池提高性能  
    参数：maxThreads、minSpareThreads、prestartminSpareThreads、maxQueueSize
- 配置内存
    CATALINA_OPTS
- 集群
    横向扩展

#### Java GC机制

### 数据结构
#### 红黑树
红黑树是一种平衡二叉查找树。  
特征：  
1. 节点是红色或黑色  
2. 根节点是黑色  
3. 每个叶子节点都是黑色的空节点  
4. 每个红色节点的两个子节点都是黑色的  
5. 从任意节点到其每个叶子节点的所有路径都包含相同数量的黑色节点  

- 变色：  
    按照特征4和5对节点变色  
- 左旋转（逆时针旋转）：  
    父节点被自己的右侧子节点取代，该父节点成为右侧子节点的左侧子节点，同时该右侧子节点的左侧子节点成为原父节点的右侧子节点  
- 右旋转（顺时针旋转）：  
    父节点被自己的左侧子节点取代，该父节点成为左侧子节点的右侧子节点，同时该左侧子节点的右侧子节点成为原父节点的左侧子节点  

### 数据库基础
#### 索引
数据库索引是为了增加查询速度而对表字段附加的一种标识。  
定位到特定值的行数，大大减少遍历匹配的行数。  
索引需要存储空间，增删改执行，字段索引重新计算更新。  

#### MySQL里主要有哪些索引结构
- Hash  
    等值查询：当查找某一条记录的时候，速度非常快。键值对，散列的方式分布，不支持范围查找和排序等功能。  
- B+Tree  
    适合范围查找和排序等操作。  
    所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key  值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度  

#### MySQL优化
1. 性能优化  
    1. 开启查询缓存  
    2. 字段大小合宜  
    3. 表的设计。垂直分割表，降低表的复杂度和字段的数目  
2. SQL语句优化  
    1. 建索引。一般在 where 及 order by 中涉及到的列上建索引，尽量不要对可以重复的字段建索引  
    2. 尽量避免在 where 中使用 !（<>）或 or，也不要进行 null 值判断  
    3. 尽量避免在 where 中对字段进行函数操作、表达式操作  

#### 为什么MyISAM会比Innodb的查询速度快
数据块，INNODB要缓存，MYISAM只缓存索引块，  这中间还有换进换出的减少；  
innodb寻址要映射到块，再到行，MYISAM记录的直接是文件的OFFSET，定位比INNODB要快  
INNODB还需要维护多版本并发控制（MVCC）一致；虽然你的场景没有，但他还是需要去检查和维护  

#### ACID
原子性（Atomicity）  
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。  
一致性（Consistency）  
事务前后数据的完整性必须保持一致。  
隔离性（Isolation）  
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。  
持久性（Durability）  
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响  

#### Innodb引擎优点  
- 支持事务  
- 通过索引行级锁定  
- 读写阻塞与事务隔离级别相关  
- 具有非常高效的缓存特性,能缓存索引,也能缓存数据  
- 整个表和主键以Cluster方式存储,组成一颗平衡树  
- 所有Secondary Index 都会保存主键信息  
- 支持分区,表空间  
- 支持外键约束,不支持全文索引  
- InnoDB对于硬件资源要求比较高

#### MySQL的事务隔离级别  
1. 读未提交  
    脏读:指一个线程中的事务读取到了另外一个线程中未提交的数据  
2. 读已提交  
    不可重复读:指一个线程中的事务读取到了另外一个线程中提交的update的数据  
3. 可重复读  
    幻读:指一个线程中的事务读取到了另外一个线程中提交的insert的数据  
4. 串行化  

#### 乐观锁、悲观锁机制
悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁  
悲观锁实现：事务隔离级别的可串行化就是典型的悲观锁机制，读加读锁，写加写锁  
乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，乐观锁适用于读多写少的应用场景  
乐观锁实现：多版本并发控制（MVCC），读不加锁写不冲突   

### Redis
- 数据结构  
    string list hash set zset  
- 线程模型  
    单线程  
- 持久机制  
    rdb：定时的持久机制  
    afo：基于操作日志的持久机制  
- 事务  
    事务并不支持回滚  
- 高可用实现  
    主从、Sentinel、Cluster  
- lru数据淘汰机制  
- 过期策略  
    定时，惰性，定期
- 问题  
    缓存雪崩  
    缓存击穿  

### 网络
#### TCP协议的三次握手和四次挥手过程

### 框架
#### Spring 
- IOC  
    通过描述来生成或获取对象的技术。在Spring中把每一个需要管理的对象称为Spring Bean，而Spring称之为Spring IOC容器。  
    IOC包括两方面的内容：一是装配Bean，通过xml配置或扫描注解；二是依赖注入，通常使用注解@Autowired，匹配Bean并注入  
- AOP  
    面向切面编程的本质是约定编程，采用代理模式，将方法织入约定的流程中；典型应用有事务处理

#### SpringMVC
轻量级MVC框架  
原理：  
通过DispatchServlet（前端控制器）接受用户的请求，调用HandlerMapping（处理器映射器）查找handler，返回HandlerExecutorChain（处理器执行链），调用HandlerAdapter（处理器适配器）去执行处理器，返回ModelAndView,调用ViewResolver（视图解析器）进行视图解析返回View，对视图进行渲染，向用户响应结果。  

#### Mybatis
原理：  
加载mybatis-config.xml配置文件，获取Configuration对象以及一个个MappedStatement对象；  
SqlSessionFactoryBuilder通过Configuration获取SqlSessionFactory来创建SqlSession；  
每当调用Mapper接口方法时，创建一个SqlSession对象，通过接口方法名称找到对应Id的MappedStatement对象；  
再由Executor对象对MappedStatement对象进行解析、sql参数转化、动态sql拼接，生成jdbc Statement对象；  
最后由JDBC执行sql，结果转换为MappedStatement对象中的结果映射。  

#### @Autowired实现原理
Spring容器启动时，AutowiredAnnotationBeanPostProcessor扫描Spring容器中的所有Bean，在Bean中发现@Autowired注解，则找到匹配的Bean并注入到对应的地方
#### Bean的作用域
默认为singleton  
还有prototype、request、session、global-session  

#### 传播行为
REQUIRED：沿用当前事务  
REQUIRED_NEW：独立事务  
NESTED：沿用当前事务，子方法回滚 当前事务不回滚




